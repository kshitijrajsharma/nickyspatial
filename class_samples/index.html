<!DOCTYPE html>
<html>
<head>
  <title>Leaflet Segment Class Assignment</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #map { width: 70%; height: 100vh; float: left; }
    #sidebar {
      width: 30%; height: 100vh; float: right;
      overflow-y: auto; padding: 10px; box-sizing: border-box;
      border-left: 1px solid #ccc; font-family: sans-serif;
    }
    .legend {
      background: white;
      padding: 8px;
      line-height: 1.4em;
      font-size: 13px;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
    }
    .legend-color {
      display: inline-block;
      width: 14px;
      height: 14px;
      margin-right: 5px;
      vertical-align: middle;
    }
    .class-input { margin-bottom: 5px; }
    .class-input input[type="text"] {
      width: 80px;
    }
    .class-section {
      margin-top: 10px;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .class-section h4 {
      margin: 4px 0;
      font-size: 14px;
    }
    .class-ids {
      font-size: 13px;
      word-wrap: break-word;
    }
	.reset_buttons{
		margin-top:20px;
	}
  </style>
</head>
<body>

<div id="map"></div>

<div id="sidebar">
  <h3>Classification Tool</h3>
  <label>Number of Classes:</label>
  <input type="number" id="classCount" min="1" value="2" />
  <button onclick="generateClassControls()">Generate</button>
  <div id="classControls"></div>

  <button onclick="resetSelections()" class = "reset_buttons">Reset</button>

  <h4>Segment IDs by Class</h4>
  <div id="classwiseIds"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  const map = L.map('map').setView([47.899167, 17.007472], 18);

  const baseLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 20, attribution: 'Â© OpenStreetMap'
  }).addTo(map);
  
  const orthoLayer = L.tileLayer('http://localhost:8000/{z}/{x}/{-y}.png', {
	  minZoom: 0,
	  maxZoom: 22,
	  attribution: 'ZXY Layer',
	  tms: false // Set to true if your tile folder structure follows TMS order (flipped Y)
	});

  // Add it to map
  orthoLayer.addTo(map);

  // Add Layer Switcher
  const baseMaps = {
    "OpenStreetMap": baseLayer
  };

  const overlayMaps = {
    "Orthophoto": orthoLayer,
	//"Segment Layer": segmentLayer
  };

  const layerControl = L.control.layers(baseMaps, overlayMaps, { collapsed: false }).addTo(map);
	

  let segmentLayer;
  let classColors = {};
  let classData = {};
  let currentClassKey = null;

  const legendControl = L.control({ position: "bottomright" });

  legendControl.onAdd = function () {
    const div = L.DomUtil.create("div", "legend");
    div.innerHTML = "<b>Legend</b><br>";
    for (let key in classColors) {
      const label = document.getElementById(`label_${key}`)?.value || key;
      div.innerHTML += `<span class="legend-color" style="background:${classColors[key]}"></span>${label}<br>`;
    }
    return div;
  };

  function generateRandomColor() {
    return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
  }

  function isEmpty(obj) {
	  if (typeof obj !== 'object' || obj === null) {
		return false; // Not an object
	  }

	  for (const key in obj) {
		if (Object.hasOwn(obj, key)) {
		  const value = obj[key];
		  
		  if (typeof value === 'object' && value !== null) {
			if (!isEmpty(value)) {
			  return false;
			}
		  } else {
			return false; // Primitive (non-object) value found
		  }
		}
	  }

	  return true;
	}

	
  function generateClassControls() {
	//console.log(classData);
	var confirm = true;
	if(!isEmpty(classData)){
		confirm = window.confirm("Your selected samples will be reset. Are you sure?")
	}
	
	if(confirm){
		resetClasses();  // Auto reset on change
		const classCount = parseInt(document.getElementById('classCount').value);
		const container = document.getElementById("classControls");
		container.innerHTML = "";
		classColors = {};
		classData = {};

		for (let i = 1; i <= classCount; i++) {
		  const key = `class_${i}`;
		  classColors[key] = generateRandomColor();
		  classData[key] = [];

		  const div = document.createElement("div");
		  div.className = "class-input";

		  div.innerHTML = `
			<input type="radio" name="classRadio" value="${key}" ${i === 1 ? "checked" : ""} onchange="currentClassKey='${key}'; updateClassIds();">
			<input type="text" id="label_${key}" value="${key}" placeholder="Class Name" oninput="updateClassIds()">
		  `;

		  container.appendChild(div);
		}

		currentClassKey = `class_1`;
		legendControl.addTo(map);
		updateClassIds();
	}
    
  }

  function updateClassIds() {
    const div = document.getElementById("classwiseIds");
    div.innerHTML = "";
    for (let key in classData) {
      const ids = classData[key].sort((a, b) => a - b);
      const label = document.getElementById(`label_${key}`)?.value || key;
      const color = classColors[key];
      const section = document.createElement("div");
      section.className = "class-section";
      section.innerHTML = `
        <h4><span class="legend-color" style="background:${color}"></span>${label}</h4>
        <div class="class-ids">${ids.join(', ') || "(none)"}</div>
      `;
      div.appendChild(section);
    }
  }

  function resetSelections() {
    if (!segmentLayer) return;
    segmentLayer.eachLayer(l => {
      const fid = l.feature.properties.segment_id;
      for (let k in classData) {
        classData[k] = classData[k].filter(id => id !== fid);
      }
      l.setStyle({ color: "#3388ff", fillOpacity: 0 });
    });
    updateClassIds();
  }

  function resetClasses() {
    document.getElementById("classControls").innerHTML = "";
    document.getElementById("classwiseIds").innerHTML = "";
    classColors = {};
    classData = {};
    currentClassKey = null;
    if (legendControl._container) legendControl.remove();
    resetSelections();
  }
  
  function removeFromAllClasses(value, classArrays) {
	  for (const className in classArrays) {
		const index = classArrays[className].indexOf(value);
		if (index !== -1) {
		  classArrays[className].splice(index, 1);
		}
	  }
	}

	function onEachFeature(feature, layer) {
	  const fid = feature.properties.segment_id;

	  layer.on('click', () => {
		if (!currentClassKey) return alert("Please select a class first!");

		const alreadyInClass = classData[currentClassKey].includes(fid);

		// Always remove from all classes first
		removeFromAllClasses(fid, classData);

		if (!alreadyInClass) {
		  // Add to current class if it wasn't there already
		  classData[currentClassKey].push(fid);

		  layer.setStyle({
			color: classColors[currentClassKey],
			fillColor: classColors[currentClassKey],
			fillOpacity: 0.6
		  });
		} else {
		  // Reset style when deselected
		  layer.setStyle({
			color: "#3388ff",
			fillColor: "#3388ff",
			fillOpacity: 0
		  });
		}

		updateClassIds();
	  });
	}


  function loadSegmentLayer(url) {
    fetch(url)
      .then(res => res.json())
      .then(data => {
        segmentLayer = L.geoJSON(data, {
          onEachFeature: onEachFeature,
          style: {
            color: "#3388ff",
            weight: 1,
            fillOpacity: 0
          }
        }).addTo(map);
		layerControl.addOverlay(segmentLayer, "Segment Layer");
      });
  }

  loadSegmentLayer("results/segment_wgs84.geojson");

  // Initial run
  generateClassControls();
  
 
</script>

</body>
</html>
